"use strict";(self.webpackChunk_woven_planet_lakefront=self.webpackChunk_woven_planet_lakefront||[]).push([[8246],{"./.storybook/DocBlock.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>__WEBPACK_DEFAULT_EXPORT__});var _storybook_blocks__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@storybook/blocks/dist/index.mjs"),react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/jsx-runtime.js");const DocBlock=()=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_storybook_blocks__WEBPACK_IMPORTED_MODULE_1__.Dx,{}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_storybook_blocks__WEBPACK_IMPORTED_MODULE_1__.QE,{}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_storybook_blocks__WEBPACK_IMPORTED_MODULE_1__.dk,{}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_storybook_blocks__WEBPACK_IMPORTED_MODULE_1__.fQ,{includePrimary:!0}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_storybook_blocks__WEBPACK_IMPORTED_MODULE_1__.Ed,{})]}),__WEBPACK_DEFAULT_EXPORT__=DocBlock;try{DocBlock.displayName="DocBlock",DocBlock.__docgenInfo={description:"",displayName:"DocBlock",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES[".storybook/DocBlock.tsx#DocBlock"]={docgenInfo:DocBlock.__docgenInfo,name:"DocBlock",path:".storybook/DocBlock.tsx#DocBlock"})}catch(__react_docgen_typescript_loader_error){}},"./src/stories/StepFunctionGraph/StepFunctionGraph.stories.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{ChoiceGraph:()=>ChoiceGraph,ComplexGraph:()=>ComplexGraph,LongGraph:()=>LongGraph,MapGraph:()=>MapGraph,SimpleGraph:()=>SimpleGraph,__namedExportsOrder:()=>__namedExportsOrder,default:()=>StepFunctionGraph_stories});var DocBlock=__webpack_require__("./.storybook/DocBlock.tsx"),react=__webpack_require__("./node_modules/react/index.js");const StepFunctionGraph_DigraphDFS=class DigraphDFS{constructor(G,s){this.marked=new Array(G.getVerticesCount()).fill(!1),this.count=0,this.validateVertex(s),this.dfsTraversal=this.dfs(G,s)}dfs(G,v){this.count++,this.marked[v]=!0;const traversal=[];for(const w of G.getAdjacencyMatrix(v))this.marked[w]||this.dfs(G,w);for(let v=0;v<G.getVerticesCount();v++)this.getMarked(v)&&traversal.push(v);return traversal}static getAllDfsPaths(data,path=[0],paths=[],endVertex=-1,endReached=!1){const datum=path[path.length-1];let lastPathReached=!1;return data[datum].length>0&&!endReached&&!lastPathReached?data[datum].forEach((val=>{if(lastPathReached||val===endVertex){if(!lastPathReached){const newPath=[...path,val];(paths=this.getAllDfsPaths(data,newPath,paths,endVertex,!0)).push(path),lastPathReached=!0}}else{const newPath=[...path,val];paths=this.getAllDfsPaths(data,newPath,paths,endVertex)}})):paths.push(path),paths}getMarked(v){return this.validateVertex(v),this.marked[v]}getCount(){return this.count}validateVertex(v){const V=this.marked.length;if(v<0||v>=V)throw new Error(`vertex ${v} is not between 0 and ${V-1}`)}static getVerticesAtDepthFromPaths(paths,exclusionArray=[],hasEndVertex=!1){const endVertex=paths.reduce(((accum,path)=>Math.max(...path)>accum?Math.max(...path):accum),0),maxDepth=paths.reduce(((accum,path)=>path.filter((v=>v!==endVertex)).length>accum?path.length:accum),0),verticesAtDepth=new Array(maxDepth).fill([]);for(let depth=0;depth<=maxDepth;depth++){const uniqueVertices=[];for(let path=0;path<paths.length;path++){const vertex=paths[path][depth];void 0===vertex||hasEndVertex&&vertex===endVertex||uniqueVertices.includes(vertex)||uniqueVertices.push(vertex)}verticesAtDepth[depth]=uniqueVertices}return hasEndVertex&&verticesAtDepth.push([endVertex]),verticesAtDepth.map((depth=>depth.filter((v=>!exclusionArray.includes(v))))).filter((depth=>depth.length>0))}};let StepFunctionUtil_WorkFlowType=function(WorkFlowType){return WorkFlowType.TASK="Task",WorkFlowType.CATCH="Catch",WorkFlowType.CHOICE="Choice",WorkFlowType.PARALLEL="Parallel",WorkFlowType.MAP="Map",WorkFlowType.SUCCEED="Succeed",WorkFlowType.START="Start",WorkFlowType.END="End",WorkFlowType}({});const connectEnds=(graph,endVertex,lastTopLevelVertex,json)=>{const adjacencyMatrix=graph.getAdjacencyMatrix();StepFunctionGraph_DigraphDFS.getAllDfsPaths(adjacencyMatrix,[0]).forEach((path=>{path.forEach((vertex=>{const node=graph.getDataByVertex(vertex),[key]=Object.keys(node),{Type,Next}=node[key],isTerminal=((json,key)=>{const{States}=json;return Object.keys(States).includes(key)})(json,key)&&!Next&&Type!==StepFunctionUtil_WorkFlowType.CHOICE;isTerminal&&graph.addEdge(vertex,endVertex)}))}))},addMetadata=(parentPath,currentKey,state)=>{const{Type}=state,nodePath=`${parentPath}${parentPath?".":""}${currentKey}`;switch(Type){case"Choice":state?.Choices&&state.Choices.forEach(((choiceState,choiceStateIdx)=>addMetadata(`${nodePath}.Choices`,choiceStateIdx,choiceState)));break;case"Parallel":state?.Branches&&state.Branches.forEach(((parallelBranch,parallelBranchIdx)=>{Object.keys(parallelBranch.States).forEach((key=>{const branchState=parallelBranch.States[key];addMetadata(`${nodePath}.Branches.${parallelBranchIdx}.States`,key,branchState)}))}));break;case"Map":if(state?.Iterator?.States){const mapIteratorStates=state.Iterator.States;Object.keys(state.Iterator.States).forEach((key=>{const iteratorState=mapIteratorStates[key];addMetadata(`${nodePath}.Iterator.States`,key,iteratorState)}))}}state?.Metadata?state.Metadata.NodePath=nodePath:state.Metadata={NodePath:nodePath}},RESERVED_KEYS=["StartAt","End"],generateStepFunctionGraph=(json,graph,connectFrom,lastStateKey,updateMetaData=!0)=>{let isLastNode=!1;0===graph.V&&(graph=>{const startNode={Start:{Type:StepFunctionUtil_WorkFlowType.START}},vertex={vertex:graph.V,data:startNode};graph.addVertex(vertex)})(graph);const nodeKeys=Object.keys(json.States),nodes=nodeKeys.filter((key=>{return name=key,!RESERVED_KEYS.includes(name);var name})).map((key=>(updateMetaData&&addMetadata("",key,json.States[key]),{[key]:json.States[key]}))).sort(((nodeA,nodeB)=>nodeA?.Metadata?.SortOrder&&nodeB?.Metadata?.SortOrder?nodeA.Metadata.SortOrder-nodeB.Metadata.SortOrder:0)),lastNode=lastStateKey||nodeKeys[nodeKeys.length-1];nodes.forEach((node=>{const[key]=Object.keys(node),vertex={vertex:graph.V,data:node},addedVertex=graph.addVertex(vertex);switch(2===graph.V&&graph.addEdge(0,1),node[key].Type){case StepFunctionUtil_WorkFlowType.PARALLEL:((node,graph,addedVertex,lastStateKey)=>{const[key]=Object.keys(node),{Branches}=node[key];Branches.forEach((branch=>{generateStepFunctionGraph(branch,graph,addedVertex,lastStateKey,!1)}))})(node,graph,addedVertex,lastNode);break;case StepFunctionUtil_WorkFlowType.MAP:((node,graph,addedVertex,lastStateKey)=>{const[key]=Object.keys(node),{Iterator}=node[key];generateStepFunctionGraph(Iterator,graph,addedVertex,lastStateKey,!1)})(node,graph,addedVertex,lastNode)}key===lastNode&&(isLastNode=!0)})),nodes.forEach((node=>{const[key]=Object.keys(node),currentVertex=graph.getVertexByData((datum=>{const[dataKey]=Object.keys(datum);return dataKey===key}));if(node[key].Type===StepFunctionUtil_WorkFlowType.CHOICE){const{Choices,Default}=node[key],choiceDefaultFindFn=datum=>{const[dataKey]=Object.keys(datum);return dataKey===Default},choiceDefaultVertex=graph.getVertexByData(choiceDefaultFindFn);"number"==typeof currentVertex&&"number"==typeof choiceDefaultVertex&&graph.addEdge(currentVertex,choiceDefaultVertex),Choices.forEach((choice=>{const{Next:choiceNext}=choice,choiceNextVertex=graph.getVertexByData((datum=>{const[dataKey]=Object.keys(datum);return dataKey===choiceNext}));"number"==typeof currentVertex&&"number"==typeof choiceNextVertex&&graph.addEdge(currentVertex,choiceNextVertex)}))}}));const connectedFromNext=nodes.reduce(((accum,node)=>{const[key]=Object.keys(node),d=node[key]||{},{Next}=d,nextVertex=graph.getVertexByData((datum=>{const[dataKey]=Object.keys(datum);return dataKey===Next}));return nextVertex?accum.concat(nextVertex):accum}),[]);nodes.forEach((node=>{const[key]=Object.keys(node),d=node[key]||{},{Catch,Next}=d,currentVertex=graph.getVertexByData((datum=>{const[dataKey]=Object.keys(datum);return dataKey===key})),foundDestinationVertex=graph.getVertexByData((datum=>{const[dataKey]=Object.keys(datum);return dataKey===Next})),destinationVertex=connectFrom?currentVertex:foundDestinationVertex;if(Catch?.forEach((catchNode=>{const catchNext=catchNode.Next,foundCatchVertex=graph.getVertexByData((datum=>{const[dataKey]=Object.keys(datum);return dataKey===catchNext}));if(foundCatchVertex&&"number"==typeof currentVertex){const catchData=graph.getDataByVertex(foundCatchVertex);graph.setVertexData({vertex:foundCatchVertex,data:{[catchNext]:{...catchData[catchNext],Type:StepFunctionUtil_WorkFlowType.CATCH,ErrorEquals:catchNode.ErrorEquals}}}),graph.addEdge(currentVertex,foundCatchVertex)}})),"number"==typeof destinationVertex&&"number"==typeof currentVertex){const isVertexConnectedFromNext=connectedFromNext.includes(currentVertex);Next&&foundDestinationVertex&&graph.addEdge(currentVertex,foundDestinationVertex),isVertexConnectedFromNext||graph.addEdge(connectFrom?connectFrom-1:currentVertex,destinationVertex)}}));const lastTopLevel=nodeKeys[nodeKeys.length-1],lastTopLevelFindFn=datum=>{const[dataKey]=Object.keys(datum);return dataKey===lastTopLevel};if(isLastNode){const endVertex=(graph=>{const endNode={End:{Type:StepFunctionUtil_WorkFlowType.END}},vertex={vertex:graph.V,data:endNode};return graph.addVertex(vertex)})(graph);graph.getVertexByData(lastTopLevelFindFn);connectEnds(graph,endVertex-1,0,json)}return graph};var _path,_path2;function _extends(){return _extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}function SvgNavigation(props){return react.createElement("svg",_extends({xmlns:"http://www.w3.org/2000/svg",height:24,viewBox:"0 0 24 24",width:24},props),_path||(_path=react.createElement("path",{d:"M0 0h24v24H0z",fill:"none"})),_path2||(_path2=react.createElement("path",{d:"M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3A8.994 8.994 0 0013 3.06V1h-2v2.06A8.994 8.994 0 003.06 11H1v2h2.06A8.994 8.994 0 0011 20.94V23h2v-2.06A8.994 8.994 0 0020.94 13H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"})))}var plus_path,plus_path2;function plus_extends(){return plus_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},plus_extends.apply(this,arguments)}function SvgPlus(props){return react.createElement("svg",plus_extends({xmlns:"http://www.w3.org/2000/svg",height:24,viewBox:"0 0 24 24",width:24},props),plus_path||(plus_path=react.createElement("path",{d:"M0 0h24v24H0z",fill:"none"})),plus_path2||(plus_path2=react.createElement("path",{d:"M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"})))}var minus_path,minus_path2;function minus_extends(){return minus_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},minus_extends.apply(this,arguments)}function SvgMinus(props){return react.createElement("svg",minus_extends({xmlns:"http://www.w3.org/2000/svg",height:24,viewBox:"0 0 24 24",width:24},props),minus_path||(minus_path=react.createElement("path",{d:"M0 0h24v24H0z",fill:"none"})),minus_path2||(minus_path2=react.createElement("path",{d:"M19 13H5v-2h14v2z"})))}const StepFunctionGraph_Digraph=class Digraph{constructor(vertices){if(vertices&&vertices<0)throw new Error("Number of vertices in a Digraph must be non-negative");if(this.V=0,this.E=0,this.adjacencyMatrix=[],this.vertexDataMap=new Map,this.indegree=Array.from({length:vertices||0},(_=>Array(0))),vertices){this.V=vertices;for(let v=0;v<vertices;v++)this.adjacencyMatrix[v]=[]}}getVerticesCount(){return this.V}getEdgeCount(){return this.E}validateVertex(v){if(v<0||v>=this.V)throw new Error(`vertex ${v} is not between 0 and ${this.V-1}`)}addEdge(v,w){this.validateVertex(v),this.validateVertex(w),this.adjacencyMatrix[v].includes(w)||this.adjacencyMatrix[v].push(w),this.indegree[w].includes(v)||this.indegree[w].push(v),this.E++}addVertex(vertex){return this.indegree.push([]),this.adjacencyMatrix[this.V++]=[],this.vertexDataMap.set(vertex.vertex,vertex.data),this.V}setVertexData(vertex){this.vertexDataMap.set(vertex.vertex,vertex.data)}getVertexByKey(vertexKey){for(const[key,value]of this.vertexDataMap.entries()){const[name]=Object.keys(value);if(name===vertexKey)return key}}getVertexByData(findFn){for(const[key,value]of this.vertexDataMap.entries())if(findFn(value))return key}getDataByVertex(vertex){return this.vertexDataMap.get(vertex)}getAdjacencyMatrix(v){return"number"==typeof v?this.adjacencyMatrix[v]:this.adjacencyMatrix}getOutdegree(v){return this.validateVertex(v),{count:this.adjacencyMatrix[v].length,outVertices:this.adjacencyMatrix[v]}}getIndegree(v){return this.validateVertex(v),this.indegree[v]??[]}},getErrorEqualsText=(key,node)=>{const{ErrorEquals}=node[key],errorEquals=ErrorEquals.toString().replace(/,/g,", ");return errorEquals?`Catch: ErrorEquals: ${errorEquals}`:""},getNodeDimensions=(text,ctx,node,isCatch=!1)=>{const textWidth=12*text.length,catchTextWidth=isCatch?Math.max(ctx?.measureText(getErrorEqualsText(text,node)).width??0,textWidth):-1;return{height:38,width:isCatch?catchTextWidth:textWidth}},drawStepNode=({ctx,x,y,text,highlight=!1})=>{const rectWidth=12*text.length,rectXPos=x-rectWidth/2,rectYPos=y-22;ctx.fillStyle=highlight?"#d9e9fd":"#ffffff",ctx.fillRect(rectXPos,rectYPos,rectWidth,34),ctx.setLineDash([5,2]),ctx.strokeStyle=highlight?"#378fee":"#16191f",ctx.lineWidth=highlight?2:1,ctx.strokeRect(rectXPos,rectYPos,rectWidth,34),ctx.fillStyle=highlight?"#378fee":"#16191f",ctx.font="14px sans-serif",ctx.textAlign="center",ctx.fillText(text,x,y)},drawCatchNode=({ctx,x,y,text,highlight=!1,node})=>{const errorEqualText=getErrorEqualsText(text,node),textWidth=12*text.length,errorTextWidth=ctx.measureText(errorEqualText).width,rectWidth=Math.max(textWidth,errorTextWidth),rectXPos=x-rectWidth/2,rectYPos=y-33;ctx.fillStyle=highlight?"#d9e9fd":"#ffffff",ctx.fillRect(rectXPos,rectYPos,rectWidth,57),ctx.setLineDash([5,2]),ctx.strokeStyle="#cc0000",ctx.lineWidth=highlight?2:1,ctx.strokeRect(rectXPos,rectYPos,rectWidth,57),ctx.fillStyle=highlight?"#378fee":"#16191f",ctx.font="14px sans-serif",ctx.textAlign="center",ctx.fillText(text,x,y);const textXPos=x+rectWidth/2-10;ctx.font="12px sans-serif",ctx.textAlign="right",ctx.fillText(errorEqualText,textXPos,y-17)},drawParallel=({ctx,x,y,width,height,highlight=!1})=>{const rectWidth=width,rectXPos=x,rectYPos=y;ctx.setLineDash([5,2]),ctx.strokeStyle=highlight?"#378fee":"#16191f",ctx.lineWidth=highlight?2:1,ctx.strokeRect(rectXPos,rectYPos,rectWidth,height),ctx.globalCompositeOperation="destination-over",ctx.fillStyle=highlight?"#d9e9fd":"#ffffff",ctx.fillRect(rectXPos+2,rectYPos,rectWidth-4,height),ctx.globalCompositeOperation="source-over"},drawMap=({ctx,x,y,width,height,highlight=!1})=>{const rectWidth=width,rectXPos=x-rectWidth/2,rectYPos=y;ctx.setLineDash([5,2]),ctx.strokeStyle=highlight?"#378fee":"#16191f",ctx.fillStyle=highlight?"#d9e9fd":"#ffffff",ctx.lineWidth=highlight?2:1,ctx.strokeRect(rectXPos-10,rectYPos-10,rectWidth,height),ctx.fillRect(rectXPos-10,rectYPos-10,rectWidth,height),ctx.strokeRect(rectXPos-5,rectYPos-5,rectWidth,height),ctx.fillRect(rectXPos-5,rectYPos-5,rectWidth,height),ctx.strokeRect(rectXPos,rectYPos,rectWidth,height),ctx.fillRect(rectXPos,rectYPos,rectWidth,height)},drawTerminalNode=({ctx,x,y,text})=>{ctx.fillStyle="#ffda75",ctx.beginPath(),ctx.arc(x,y,26,0,360,!1),ctx.fill();const yPos=y+4;ctx.fillStyle="#16191f",ctx.font="14px sans-serif",ctx.textAlign="center",ctx.fillText(text,x,yPos)},calculateDistance=(from,to)=>Math.sqrt(Math.pow(to.x-from.x,2)+Math.pow(to.y-from.y,2)),drawArrow=(ctx,drawn,from,to,radius,skipArrowHead=!1,offsetStart=!1,endArrow=!1,endOffset=0)=>{to.y+=endOffset;const xCenter=to.x,yCenter=to.y-radius/2,fromOffset=offsetStart?radius:0;let angle,x,y;ctx.lineWidth=1,ctx.fillStyle="#16191f",ctx.strokeStyle="#16191f",ctx.setLineDash([]),ctx.beginPath(),ctx.moveTo(from.x,from.y+fromOffset);const cYTo=from.x===to.x?to.y:to.y+15+(to.y-from.y)/3,controlY1=endArrow?cYTo:from.y+30,controlY2=endArrow?to.y-15:from.y+15,lowestBarrier=((from,to,drawn)=>{let lowest=null;const invert=to.x>from.x;return drawn.forEach((nodeDimensions=>{const{collisionBox}=nodeDimensions,{top,right,left,bottom}=collisionBox;(invert&&right.x<to.x&&right.x>from.x&&right.y<to.y&&right.y>from.y||invert&&top.x<to.x&&top.x>from.x&&top.y<to.y&&top.y>from.y||invert&&left.x<to.x&&left.x>from.x&&left.y<to.y&&left.y>from.y||!invert&&right.x>to.x&&right.x<from.x&&right.y<to.y&&right.y>from.y||!invert&&top.x>to.x&&top.x<from.x&&top.y<to.y&&top.y>from.y||!invert&&left.x>to.x&&left.x<from.x&&left.y<to.y&&left.y>from.y)&&(!lowest||bottom.y>lowest?.collisionBox?.bottom?.y)&&(lowest=nodeDimensions)})),lowest})({x:from.x,y:to.y-(38+3*Y_OFFSET)},to,drawn),barrierConditions=Math.abs(to.y-from.y)>5*(38+Y_OFFSET);let toX=0;if(null!==lowestBarrier&&barrierConditions){const{collisionBox}=lowestBarrier,leftDistance=calculateDistance(collisionBox.left,from),rightDistance=calculateDistance(collisionBox.right,from),invert=leftDistance>rightDistance?1:-1,dX=invert*(to.x-from.x)/10,collisionX=leftDistance>rightDistance?collisionBox.right.x:collisionBox.left.x,collisionY=1===invert?collisionBox.left.y:collisionBox.right.y;toX=1===invert&&to.x<from.x?collisionX-dX/2:collisionX+dX/2,ctx.bezierCurveTo(from.x,from.y+(to.y-from.y)/2,collisionX+dX,from.y+15,toX,collisionY)}ctx.bezierCurveTo(null!==lowestBarrier&&barrierConditions?toX:from.x,null!==lowestBarrier&&barrierConditions?to.y:controlY1,to.x,controlY2,to.x,yCenter),ctx.stroke(),ctx.closePath(),ctx.beginPath(),skipArrowHead||(angle=Math.PI/180*90,x=radius*Math.cos(angle)+xCenter,y=radius*Math.sin(angle)+yCenter,ctx.moveTo(x,y),angle+=2*Math.PI/3,x=radius*Math.cos(angle)+xCenter,y=radius*Math.sin(angle)+yCenter,ctx.lineTo(x,y),angle+=2*Math.PI/3,x=radius*Math.cos(angle)+xCenter,y=radius*Math.sin(angle)+yCenter,ctx.lineTo(x,y)),ctx.closePath(),ctx.fill(),ctx.stroke()};try{drawStepNode.displayName="drawStepNode",drawStepNode.__docgenInfo={description:"",displayName:"drawStepNode",props:{text:{defaultValue:null,description:"",name:"text",required:!0,type:{name:"string"}},highlight:{defaultValue:{value:"false"},description:"",name:"highlight",required:!1,type:{name:"boolean"}},ctx:{defaultValue:null,description:"",name:"ctx",required:!0,type:{name:"CanvasRenderingContext2D"}},x:{defaultValue:null,description:"",name:"x",required:!0,type:{name:"number"}},y:{defaultValue:null,description:"",name:"y",required:!0,type:{name:"number"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/StepFunctionGraph/canvasUtil.tsx#drawStepNode"]={docgenInfo:drawStepNode.__docgenInfo,name:"drawStepNode",path:"src/components/StepFunctionGraph/canvasUtil.tsx#drawStepNode"})}catch(__react_docgen_typescript_loader_error){}try{drawCatchNode.displayName="drawCatchNode",drawCatchNode.__docgenInfo={description:"",displayName:"drawCatchNode",props:{text:{defaultValue:null,description:"",name:"text",required:!0,type:{name:"string"}},highlight:{defaultValue:{value:"false"},description:"",name:"highlight",required:!1,type:{name:"boolean"}},ctx:{defaultValue:null,description:"",name:"ctx",required:!0,type:{name:"CanvasRenderingContext2D"}},x:{defaultValue:null,description:"",name:"x",required:!0,type:{name:"number"}},y:{defaultValue:null,description:"",name:"y",required:!0,type:{name:"number"}},node:{defaultValue:null,description:"",name:"node",required:!0,type:{name:"any"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/StepFunctionGraph/canvasUtil.tsx#drawCatchNode"]={docgenInfo:drawCatchNode.__docgenInfo,name:"drawCatchNode",path:"src/components/StepFunctionGraph/canvasUtil.tsx#drawCatchNode"})}catch(__react_docgen_typescript_loader_error){}try{drawParallel.displayName="drawParallel",drawParallel.__docgenInfo={description:"",displayName:"drawParallel",props:{height:{defaultValue:null,description:"",name:"height",required:!0,type:{name:"number"}},width:{defaultValue:null,description:"",name:"width",required:!0,type:{name:"number"}},ctx:{defaultValue:null,description:"",name:"ctx",required:!0,type:{name:"CanvasRenderingContext2D"}},x:{defaultValue:null,description:"",name:"x",required:!0,type:{name:"number"}},y:{defaultValue:null,description:"",name:"y",required:!0,type:{name:"number"}},highlight:{defaultValue:{value:"false"},description:"",name:"highlight",required:!1,type:{name:"boolean"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/StepFunctionGraph/canvasUtil.tsx#drawParallel"]={docgenInfo:drawParallel.__docgenInfo,name:"drawParallel",path:"src/components/StepFunctionGraph/canvasUtil.tsx#drawParallel"})}catch(__react_docgen_typescript_loader_error){}try{drawMap.displayName="drawMap",drawMap.__docgenInfo={description:"",displayName:"drawMap",props:{height:{defaultValue:null,description:"",name:"height",required:!0,type:{name:"number"}},width:{defaultValue:null,description:"",name:"width",required:!0,type:{name:"number"}},ctx:{defaultValue:null,description:"",name:"ctx",required:!0,type:{name:"CanvasRenderingContext2D"}},x:{defaultValue:null,description:"",name:"x",required:!0,type:{name:"number"}},y:{defaultValue:null,description:"",name:"y",required:!0,type:{name:"number"}},highlight:{defaultValue:{value:"false"},description:"",name:"highlight",required:!1,type:{name:"boolean"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/StepFunctionGraph/canvasUtil.tsx#drawMap"]={docgenInfo:drawMap.__docgenInfo,name:"drawMap",path:"src/components/StepFunctionGraph/canvasUtil.tsx#drawMap"})}catch(__react_docgen_typescript_loader_error){}try{drawTerminalNode.displayName="drawTerminalNode",drawTerminalNode.__docgenInfo={description:"",displayName:"drawTerminalNode",props:{text:{defaultValue:null,description:"",name:"text",required:!0,type:{name:"string"}},highlight:{defaultValue:{value:"false"},description:"",name:"highlight",required:!1,type:{name:"boolean"}},ctx:{defaultValue:null,description:"",name:"ctx",required:!0,type:{name:"CanvasRenderingContext2D"}},x:{defaultValue:null,description:"",name:"x",required:!0,type:{name:"number"}},y:{defaultValue:null,description:"",name:"y",required:!0,type:{name:"number"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/StepFunctionGraph/canvasUtil.tsx#drawTerminalNode"]={docgenInfo:drawTerminalNode.__docgenInfo,name:"drawTerminalNode",path:"src/components/StepFunctionGraph/canvasUtil.tsx#drawTerminalNode"})}catch(__react_docgen_typescript_loader_error){}const getCatchVertices=(catchArray,graph)=>(catchArray?.map((e=>e.Next))??[]).map((catchNext=>graph.getVertexByData((datum=>{const[dataKey]=Object.keys(datum);return dataKey===catchNext}))??-1)).filter((v=>-1!==v)),generateMountingPoints=(node,topOffset,bottomOffset,leftOffset=0,rightOffset=0)=>{const bottom={x:node.x,y:node.y+node.height/2+bottomOffset/2},top={x:node.x,y:node.y-node.height/2-topOffset/2},left={x:node.x-node.width/2-leftOffset,y:node.y},right={x:node.x+node.width/2+rightOffset,y:node.y};return node.nodeType===StepFunctionUtil_WorkFlowType.PARALLEL&&(bottom.x+=node.width/2,bottom.y+=node.height/2,top.x+=node.width/2,top.y+=node.height/2+topOffset/2,left.x+=node.width/2,left.y+=node.height/2,right.x+=node.width/2,right.y+=node.height/2),{bottom,top,left,right}},findNearestArrowNode=(path,vertex,index,drawn,isStart)=>{const node=drawn.get(vertex),nextNode=drawn.get(path[index+1]);if(node&&nextNode)return isStart?node:nextNode},adjustDepthMatrix=(matrix,graph)=>{const workingMatrix=[...matrix],endIndex=workingMatrix.length-1,[endVertex]=workingMatrix[endIndex],mapEnds=[];let adjustedMatrix=[],removalArray=[];for(let i=0;i<workingMatrix.length;i++){const vertices=workingMatrix[i],adjusted=vertices.reduce(((accum,vertex)=>{const node=graph.getDataByVertex(vertex),[key]=Object.keys(node),{Catch,Next,Type}=node[key];if(Type===StepFunctionUtil_WorkFlowType.PARALLEL||Type===StepFunctionUtil_WorkFlowType.MAP){const nextVertexFindFn=datum=>{const[dataKey]=Object.keys(datum);return dataKey===Next},nextVertex=graph.getVertexByData(nextVertexFindFn);Type===StepFunctionUtil_WorkFlowType.MAP&&mapEnds.push(nextVertex??-1);const outDegree=graph.getOutdegree(vertex).outVertices.filter((v=>v!==endVertex)),catchVertices=getCatchVertices(Catch,graph);if(catchVertices.length>0&&"number"==typeof nextVertex){const nextDepthIndex=workingMatrix.findIndex((depth=>depth.includes(nextVertex)));workingMatrix[nextDepthIndex].push(...catchVertices)}accum=accum.concat(outDegree).filter((v=>v!==nextVertex&&!catchVertices.includes(v))),vertices.some((v=>outDegree.includes(v)))||(removalArray=removalArray.concat(outDegree).filter((v=>v!==nextVertex)))}return removalArray.includes(vertex)?accum:accum.concat(vertex)}),[]);adjustedMatrix.push(Array.from(new Set(adjusted)))}adjustedMatrix=adjustedMatrix.filter((depth=>depth.length>0)),removalArray.length>0&&(removalArray=[],adjustedMatrix=adjustDepthMatrix(adjustedMatrix,graph));const flatMatrix=adjustedMatrix.flat();return flatMatrix.forEach(((v,index)=>{const next=flatMatrix[index+1];if(mapEnds.includes(v)&&v>next){const largerDepth=adjustedMatrix.findIndex((depth=>depth.includes(v))),largerIndex=adjustedMatrix[largerDepth].indexOf(v),smallerDepth=adjustedMatrix.findIndex((depth=>depth.includes(next))),smallerIndex=adjustedMatrix[smallerDepth].indexOf(next);adjustedMatrix[largerDepth][largerIndex]=next,adjustedMatrix[smallerDepth][smallerIndex]=v}})),adjustedMatrix},getNextVertex=(vertex,graph)=>{if("number"==typeof vertex){const mapData=graph.getDataByVertex(vertex)||{},[node]=Object.keys(mapData),{Next=null,End=!1}=node?mapData[node]:{},defaultVertex=End?graph.getVerticesCount()-1:-1,nextVertexFindFn=datum=>{const[dataKey]=Object.keys(datum);return dataKey===Next};return graph.getVertexByData(nextVertexFindFn)??defaultVertex}return-1},getNearestDrawn=(vertex,graph,drawn)=>{if(drawn.get(vertex))return vertex;{const[outDegree]=graph.getOutdegree(vertex).outVertices;return void 0!==outDegree?getNearestDrawn(outDegree,graph,drawn):-1}},getGroupIndex=(groups,vertex)=>groups.reduce(((group,current,index)=>current.includes(vertex)?index:group),-1),isSameLevelType=workflowType=>workflowType===StepFunctionUtil_WorkFlowType.PARALLEL||workflowType===StepFunctionUtil_WorkFlowType.MAP,Y_OFFSET=75,GraphRenderer_handleMap=(ctx,vertex,endVertex,graph,drawn,highlight,highlighted)=>{const mapNode=graph.getDataByVertex(vertex),[key]=Object.keys(mapNode),{Iterator,End}=mapNode[key],{States}=Iterator,nestedNext=(Object.values(States)||[]).reduce(((next,current)=>{const{Next}=current;let nextNode=graph.getVertexByData((datum=>{const[dataKey]=Object.keys(datum);return dataKey===Next}));return nextNode&&(nextNode=getNearestDrawn(nextNode,graph,drawn)),nextNode||next}),-1),nextVertex=getNextVertex(vertex,graph),endPathVertex=~nextVertex?nextVertex:nestedNext,paths=StepFunctionGraph_DigraphDFS.getAllDfsPaths(graph.getAdjacencyMatrix(),[vertex],void 0,endPathVertex),exclusionArray=[vertex,endVertex];if(-1!==nextVertex)for(let index=nextVertex;index<endVertex;index++)exclusionArray.push(index);const mapNodeMatrix=StepFunctionGraph_DigraphDFS.getVerticesAtDepthFromPaths(paths,exclusionArray),baselineNode=drawn.get(mapNodeMatrix[0][0]),baselineWidth=baselineNode?baselineNode.width:0,widestNode=mapNodeMatrix.reduce(((accum,current)=>{const widestX=current.reduce(((accum,currentDepthVertex)=>{const drawnVertex=drawn.get(currentDepthVertex)||{width:0},[indegree]=graph.getIndegree(currentDepthVertex),indegreeNode=graph.getDataByVertex(indegree)||{},[key]=indegreeNode?Object.keys(indegreeNode):[""],{Type:indegreeType}=indegreeNode[key];let width=drawnVertex?drawnVertex.width:0;return indegree===vertex||indegreeType!==StepFunctionUtil_WorkFlowType.MAP&&indegreeType!==StepFunctionUtil_WorkFlowType.PARALLEL||(width+=40),width>accum?width:accum}),baselineWidth);return widestX>accum?widestX:accum}),baselineWidth),lastDepth=mapNodeMatrix[mapNodeMatrix.length-1],flatMatrix=mapNodeMatrix.flat(),topLeftNode=flatMatrix.find((vertex=>drawn.get(vertex)))??flatMatrix[0],bottomRightNode=lastDepth[lastDepth.length-1],topLeft=drawn.get(topLeftNode),bottomRight=drawn.get(bottomRightNode),topLeftPos={x:topLeft?topLeft.x:0,y:topLeft?topLeft.y:0,width:topLeft?topLeft.width:0},bottomRightPos_y=(bottomRight&&bottomRight.x,bottomRight?bottomRight.y:0),bottomRightPos_height=bottomRight?bottomRight.height:0,mapArgs=(bottomRight&&bottomRight.width,{ctx,x:topLeftPos.x,y:topLeftPos.y-bottomRightPos_height,width:widestNode+40,height:-(topLeftPos.y-bottomRightPos_y)+bottomRightPos_height+30,highlight});drawMap(mapArgs);[].concat(...mapNodeMatrix).forEach((vertex=>{((vertex,ctx,drawn,graph,highlighted)=>{const dimensions=drawn.get(vertex),node=graph.getDataByVertex(vertex);if(node){const[key]=Object.keys(node),{Type}=node[key],{x=0,y=0}=dimensions||{},highlight=highlighted.includes(vertex);switch(Type){case StepFunctionUtil_WorkFlowType.CHOICE:case StepFunctionUtil_WorkFlowType.TASK:drawStepNode({ctx,x,y,text:key,highlight});break;case StepFunctionUtil_WorkFlowType.CATCH:drawCatchNode({ctx,x,y,text:key,highlight,node});break;case StepFunctionUtil_WorkFlowType.PARALLEL:case StepFunctionUtil_WorkFlowType.MAP:case StepFunctionUtil_WorkFlowType.START:case StepFunctionUtil_WorkFlowType.END:break;default:drawStepNode({ctx,x,y,text:key,highlight})}}})(vertex,ctx,drawn,graph,highlighted)}));const nodeData={x:mapArgs.x,y:mapArgs.y+mapArgs.height/2+5,width:mapArgs.width,height:mapArgs.height,nodeType:StepFunctionUtil_WorkFlowType.MAP,vertex,end:!!End},drawnData={...nodeData,mountingPoints:generateMountingPoints(nodeData,17,-5),collisionBox:generateMountingPoints(nodeData,26,0,12)};drawn.set(vertex,drawnData)},getX=(groups,vertex,nodeWidth,canvasWidth,range,previousEnd,previousVertex,graph,drawn,endVertex,delayed,renderParams)=>{const isEnd=vertex===endVertex,indegrees=graph.getIndegree(vertex),previousIndegrees=graph.getIndegree(previousVertex),grandparentIndegrees=indegrees?graph.getIndegree(indegrees[indegrees.length-1]):[],indegreeOverlap=!(!previousIndegrees||!indegrees)&&indegrees.some((v=>previousIndegrees.includes(v))),currentGroupIndex=getGroupIndex(groups,vertex),isInPreviousGroup=currentGroupIndex===getGroupIndex(groups,previousVertex),parentNode=indegrees[indegrees.length-1],flattened=[].concat(...groups),drawnParent=graph.getDataByVertex(parentNode)||{},[key]=Object.keys(drawnParent),{Type:parentType=""}=key?drawnParent[key]:{},mapParentPosition=parentType===StepFunctionUtil_WorkFlowType.MAP&&grandparentIndegrees.length>0?drawn.get(grandparentIndegrees[grandparentIndegrees.length-1]):null,parentPosition=drawn.get(parentNode)||mapParentPosition,nextVertex=getNextVertex(parentNode,graph),parentOutdegree=parentNode?graph.getOutdegree(parentNode).outVertices:[],isParallelNext=nextVertex===vertex&&parentType===StepFunctionUtil_WorkFlowType.PARALLEL,parallelRange=((vertices,graph,drawn)=>{const xValues=vertices.reduce(((accum,vertex)=>{const xVal=drawn.get(vertex)?.x;return"number"==typeof xVal&&accum.push(xVal),accum}),[]);return(Math.min(...xValues)+Math.max(...xValues))/2})(parentOutdegree,0,drawn);let newPositionByPrevious=previousEnd+nodeWidth/2+30;const[previousParent]=graph.getIndegree(previousVertex),previousParentVertexData=graph.getDataByVertex(previousParent)||{},[previousParentKey]=Object.keys(previousParentVertexData),{Type:previousParentType=""}=previousParentKey?previousParentVertexData[previousParentKey]:{};previousParentType===StepFunctionUtil_WorkFlowType.MAP&&(newPositionByPrevious+=15);const parentX=parentPosition?parentPosition.x:canvasWidth/4,positionByPrevious=~previousEnd&&isSameLevelType(parentType)||~previousEnd&&!isInPreviousGroup||parentType===StepFunctionUtil_WorkFlowType.CHOICE;let positionByParent=parentType!==StepFunctionUtil_WorkFlowType.CHOICE&&(!~previousEnd&&!isSameLevelType(parentType)||!indegreeOverlap&&parentType!==StepFunctionUtil_WorkFlowType.PARALLEL||isParallelNext);const currentGroup=groups[currentGroupIndex],rangeLength=groups.length>1?currentGroup.length:flattened.length;let rangePosition=~previousEnd?previousEnd+30:rangeLength>1?parentX-range/2+nodeWidth/2:canvasWidth/4;!~previousEnd&&groups.length>1&&(rangePosition/=2),parentType===StepFunctionUtil_WorkFlowType.CHOICE&&!isInPreviousGroup&&flattened.length>2&&(rangePosition+=60),positionByPrevious&&positionByParent&&parentX<newPositionByPrevious&&parentType!==StepFunctionUtil_WorkFlowType.PARALLEL&&(positionByParent=!1);const isDelayed=delayed.filter((d=>d[4]===previousVertex)).length>0||null===parentX;if(positionByPrevious&&!positionByParent||isDelayed){const[previousIndegreeVertex]=previousIndegrees||[],graphPreviousIndegree=graph.getDataByVertex(previousIndegreeVertex)||{},[previousKey]=Object.keys(graphPreviousIndegree),{Type:previousIndegreeType=""}=previousKey?graphPreviousIndegree[previousKey]:{},drawnPreviousIndegree=drawn.get(previousIndegreeVertex),drawnPreviousNode=drawn.get(previousVertex);if((previousIndegreeType===StepFunctionUtil_WorkFlowType.PARALLEL||previousIndegreeType===StepFunctionUtil_WorkFlowType.MAP)&&parentType!==StepFunctionUtil_WorkFlowType.PARALLEL||isDelayed){if(!(delayed.filter((d=>d[4]===vertex)).length>0&&drawnPreviousIndegree))return delayed.push(renderParams),null;previousIndegreeType===StepFunctionUtil_WorkFlowType.PARALLEL?rangePosition=drawnPreviousIndegree.collisionBox.right.x+nodeWidth/2+30:drawnPreviousNode&&(rangePosition=drawnPreviousNode.collisionBox.right.x+nodeWidth/2+30)}}let calculatedX;return(positionByPrevious&&parentType===StepFunctionUtil_WorkFlowType.MAP||!positionByPrevious&&groups.length>1)&&(positionByParent=!1),calculatedX=isEnd?canvasWidth/4:positionByPrevious&&!positionByParent?rangePosition:positionByParent?isParallelNext&&!isNaN(parallelRange)?parallelRange:parentX:rangePosition,~previousEnd&&calculatedX<=newPositionByPrevious&&(calculatedX=newPositionByPrevious),calculatedX};function renderVertex(depthWithoutParallel,index,drawn,graph,vertex,groups,width,endVertex,depthIndex,highlighted,ctx,delayed){const previousVertex=depthWithoutParallel[index-1],previous=drawn.get(previousVertex);let previousEnd=previous?previous.collisionBox.right.x:-1;const node=graph.getDataByVertex(vertex),[key]=Object.keys(node),{Type,End}=node[key],isCatch=Type===StepFunctionUtil_WorkFlowType.CATCH,{height:nodeHeight,width:nodeWidth}=getNodeDimensions(key,ctx,node,isCatch),xOffset=[].concat(...groups).length>1?30:0,range=((vertices,xOffset,graph,ctx)=>vertices.reduce(((accum,current)=>{const nodeData=graph.getDataByVertex(current),[rangeKey]=Object.keys(nodeData),{Type}=nodeData[rangeKey],{width:currentWidth}=getNodeDimensions(rangeKey,ctx,nodeData,Type===StepFunctionUtil_WorkFlowType.CATCH);return accum+(Type===StepFunctionUtil_WorkFlowType.PARALLEL?0:currentWidth)+xOffset}),0))(groups[getGroupIndex(groups,vertex)]??[],xOffset,graph,ctx),x=getX(groups,vertex,nodeWidth,width,range,previousEnd,previousVertex,graph,drawn,endVertex,delayed,arguments),y=((depth,nodeHeight)=>depth*(nodeHeight+Y_OFFSET)+Y_OFFSET)(depthIndex,nodeHeight),highlight=highlighted.includes(vertex);if(x)switch(Type){case StepFunctionUtil_WorkFlowType.START:case StepFunctionUtil_WorkFlowType.END:drawTerminalNode({ctx,x,y,text:key});break;case StepFunctionUtil_WorkFlowType.TASK:case StepFunctionUtil_WorkFlowType.CHOICE:drawStepNode({ctx,x,y,text:key,highlight});break;case StepFunctionUtil_WorkFlowType.CATCH:drawCatchNode({ctx,x,y,text:key,highlight,node});break;case StepFunctionUtil_WorkFlowType.MAP:case StepFunctionUtil_WorkFlowType.PARALLEL:break;default:drawStepNode({ctx,x,y,text:key,highlight})}const nodeData={x,y,width:nodeWidth,height:nodeHeight,nodeType:Type,vertex,end:!!End},topOffset=Type===StepFunctionUtil_WorkFlowType.START||Type===StepFunctionUtil_WorkFlowType.END?17:10,bottomOffset=Type===StepFunctionUtil_WorkFlowType.START||Type===StepFunctionUtil_WorkFlowType.END?22:-5,drawnData={...nodeData,mountingPoints:generateMountingPoints(nodeData,isCatch?38:topOffset,isCatch?19:bottomOffset),collisionBox:generateMountingPoints(nodeData,isCatch?38:topOffset,isCatch?19:bottomOffset)};drawn.set(vertex,drawnData)}const drawGraph=(canvasRef,drawn,traversals,graph,ctx,pan,scale,height,width,highlighted=[])=>{const xTransform=-(scale-1)*width/2,yTransform=-(scale-1)*height/2,scaledWidth=Math.abs(pan.offset.x)/scale,scaledHeight=Math.abs(pan.offset.y)/scale;let verticesAtDepth=StepFunctionGraph_DigraphDFS.getVerticesAtDepthFromPaths(traversals,[],!0);verticesAtDepth=adjustDepthMatrix(verticesAtDepth,graph);const allVertices=[].concat(...verticesAtDepth),endVertex=graph.getVerticesCount()-1;ctx.setTransform(scale,0,0,scale,xTransform,yTransform),ctx.clearRect(0-scaledWidth,0-scaledHeight,width+scaledWidth,height+scaledHeight),ctx.translate(pan.offset.x,pan.offset.y);const delayed=[];verticesAtDepth.sort((([a],[b])=>a-b)),verticesAtDepth.forEach(((depth,depthIndex)=>{const groups=((depthArray,graph)=>{const groups=[],toFilter=[];depthArray.forEach((vertex=>{const group=[],node=graph.getDataByVertex(vertex),[key]=Object.keys(node),{Type}=node[key];if(Type===StepFunctionUtil_WorkFlowType.PARALLEL){const nextVertex=getNextVertex(vertex,graph),outDegree=graph.getOutdegree(vertex).outVertices.filter((v=>v!==nextVertex));group.push(...outDegree),groups.push(group),toFilter.push(vertex)}}));const flattenedGroups=[].concat(...groups),notInGroups=depthArray.filter((v=>!toFilter.includes(v)&&!flattenedGroups.includes(v)));return notInGroups.length>0&&groups.push(notInGroups),groups})(depth,graph),depthWithoutParallel=depth.filter((vertex=>{const node=graph.getDataByVertex(vertex),[key]=Object.keys(node),{Type}=node[key];return Type!==StepFunctionUtil_WorkFlowType.PARALLEL&&Type!==StepFunctionUtil_WorkFlowType.MAP}));depthWithoutParallel.forEach(((vertex,index)=>{renderVertex(depthWithoutParallel,index,drawn,graph,vertex,groups,width,endVertex,depthIndex,highlighted,ctx,delayed)}))}));[...allVertices].sort(((a,b)=>a-b)).forEach((vertex=>{const node=graph.getDataByVertex(vertex),[key]=Object.keys(node),{Type}=node[key],highlight=highlighted.includes(vertex);Type===StepFunctionUtil_WorkFlowType.PARALLEL?((ctx,graph,vertex,endVertex,drawn,highlight)=>{const parallelNode=graph.getDataByVertex(vertex),[key]=Object.keys(parallelNode),{Catch,End}=parallelNode[key],nextVertex=getNextVertex(vertex,graph),exclusionArray=[vertex,endVertex,...getCatchVertices(Catch,graph)];if(-1!==nextVertex)for(let index=nextVertex;index<endVertex;index++)exclusionArray.push(index);const paths=StepFunctionGraph_DigraphDFS.getAllDfsPaths(graph.getAdjacencyMatrix(),[vertex]),parallelNodeMatrix=StepFunctionGraph_DigraphDFS.getVerticesAtDepthFromPaths(paths,exclusionArray),flatMatrix=parallelNodeMatrix.flat(),topLeftNode=flatMatrix.find((vertex=>drawn.get(vertex)))??flatMatrix[0],baselineNode=drawn.get(topLeftNode),baselineX=baselineNode?baselineNode.x:0,leftMostX=parallelNodeMatrix.reduce(((accum,current)=>{const smallestX=current.reduce(((accum,currentDepthVertex)=>{const drawnVertex=drawn.get(currentDepthVertex),x=drawnVertex?drawnVertex.mountingPoints.left.x:accum;return x<accum?x:accum}),baselineX);return smallestX<accum?smallestX:accum}),baselineX),range=parallelNodeMatrix.reduce(((accum,current)=>{const currentRange=((vertices,graph,drawn,leftMostX)=>{const sorted=vertices.sort(((a,b)=>a-b)),first=drawn.get(sorted[0]),last=drawn.get(vertices[sorted.length-1]),firstLeft=leftMostX??(first?first.mountingPoints.left.x:0),lastRight=last?last.mountingPoints.right.x:0;return(first||firstLeft)&&last?lastRight-firstLeft:0})(current,0,drawn,leftMostX);return currentRange>accum?currentRange:accum}),0),lastDepth=parallelNodeMatrix[parallelNodeMatrix.length-1],bottomRightNode=lastDepth[lastDepth.length-1],topLeft=drawn.get(topLeftNode),bottomRight=drawn.get(bottomRightNode),topLeftPos_y=(topLeft&&topLeft.x,topLeft?topLeft.y:0),bottomRightPos_y=(topLeft&&topLeft.width,bottomRight&&bottomRight.collisionBox.right.x,bottomRight?bottomRight.y:0),bottomRightPos_height=bottomRight?bottomRight.height:0,parallelArgs=(bottomRight&&bottomRight.width,{ctx,x:topLeft?leftMostX-10:leftMostX,y:topLeftPos_y-bottomRightPos_height-20-1,width:range+20,height:-(topLeftPos_y-bottomRightPos_y)+bottomRightPos_height+60,highlight});drawParallel(parallelArgs);const nodeData={x:parallelArgs.x,y:parallelArgs.y,width:parallelArgs.width,height:parallelArgs.height,nodeType:StepFunctionUtil_WorkFlowType.PARALLEL,vertex,end:!!End},drawnData={...nodeData,mountingPoints:generateMountingPoints(nodeData,-5,0),collisionBox:generateMountingPoints(nodeData,-5,0)};drawn.set(vertex,drawnData)})(ctx,graph,vertex,endVertex,drawn,highlight):Type===StepFunctionUtil_WorkFlowType.MAP&&GraphRenderer_handleMap(ctx,vertex,endVertex,graph,drawn,highlight,highlighted)})),delayed.forEach((delayedDraw=>{const[depthWithoutParallel,index,,graph,vertex,groups,width,endVertex,depthIndex,highlighted,ctx,delayed]=delayedDraw;renderVertex(depthWithoutParallel,index,drawn,graph,vertex,groups,width,endVertex,depthIndex,highlighted,ctx,delayed)}));const allPaths=StepFunctionGraph_DigraphDFS.getAllDfsPaths(graph.getAdjacencyMatrix(),[0],void 0),drawnArrowPairs=[];allPaths.forEach((path=>{path.forEach(((vertex,index)=>{const node=findNearestArrowNode(path,vertex,index,drawn,!0),nextNode=findNearestArrowNode(path,vertex,index,drawn,!1),alreadyDrawn=~drawnArrowPairs.findIndex((tuple=>{const[n1,n2]=tuple;return n1===node?.vertex&&n2===nextNode?.vertex}));if(node&&nextNode&&node.vertex!==nextNode.vertex&&nextNode.nodeType&&!alreadyDrawn){const{mountingPoints:mount0}=node,{mountingPoints:mount1}=nextNode,nextEnd=nextNode.nodeType===StepFunctionUtil_WorkFlowType.END;if(mount0&&mount1&&mount0.bottom.y<mount1.top.y&&node.nodeType!==StepFunctionUtil_WorkFlowType.PARALLEL)drawArrow(ctx,drawn,mount0.bottom,mount1.top,5,!1,!1,nextEnd),drawnArrowPairs.push([node.vertex,nextNode.vertex]);else if(nextNode.nodeType===StepFunctionUtil_WorkFlowType.END)drawArrow(ctx,drawn,mount0.bottom,mount1.top,5,!1,!1,!0),drawnArrowPairs.push([node.vertex,nextNode.vertex]);else{const offsetArrowStart=node.nodeType===StepFunctionUtil_WorkFlowType.PARALLEL,hideArrow=node.nodeType===StepFunctionUtil_WorkFlowType.MAP,endOffset=hideArrow?5:0,parallelNode=graph.getDataByVertex(vertex),[parallelNodeKey]=Object.keys(parallelNode),{Catch,End,Next}=parallelNode[parallelNodeKey],nextVertexFindFn=datum=>{const[dataKey]=Object.keys(datum);return dataKey===Next},catchVertices=getCatchVertices(Catch,graph),connectingNode=graph.getVertexByData(nextVertexFindFn),bottomArrow=End||nextNode.vertex!==connectingNode?mount0.top:mount0.bottom;catchVertices.includes(nextNode.vertex)?(drawArrow(ctx,drawn,mount0.bottom,mount1.top,5,hideArrow,offsetArrowStart,nextEnd,endOffset),drawnArrowPairs.push([node.vertex,nextNode.vertex])):(drawArrow(ctx,drawn,bottomArrow,mount1.top,5,hideArrow,offsetArrowStart,nextEnd,endOffset),drawnArrowPairs.push([node.vertex,nextNode.vertex]))}}}))}))};var resizeObserver=__webpack_require__("./src/lib/hooks/resizeObserver.js");const throttle=(delay,fn)=>{let lastCall=0;return function(...args){const now=(new Date).getTime();if(!(now-lastCall<delay))return lastCall=now,fn(...args)}};var emotion_styled_browser_esm=__webpack_require__("./node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js");const GraphContainer=emotion_styled_browser_esm.Z.div({height:"100%",margin:0,position:"relative"}),StyledCanvas=emotion_styled_browser_esm.Z.canvas({cursor:"grab",height:"100%",width:"100%"}),GraphControls=emotion_styled_browser_esm.Z.div((({theme})=>({bottom:16,display:"flex",flexDirection:"column",position:"absolute",right:16,svg:{height:17},div:{backgroundColor:theme?.colors?.storm,borderRadius:2,cursor:"pointer",display:"flex",justifyContent:"center",alignItems:"center",opacity:.8,height:32,width:32},"div:first-of-type":{marginBottom:15},"div:nth-of-type(2)":{borderBottomLeftRadius:0,borderBottomRightRadius:0},"div:nth-of-type(3)":{borderTopLeftRadius:0,borderTopRightRadius:0,borderTop:`1px solid ${theme?.colors?.dolphin}`},"svg path:nth-of-type(2)":{fill:theme?.colors?.mercury}})));var theme=__webpack_require__("./src/styles/theme.ts"),emotion_element_6a883da9_browser_esm=__webpack_require__("./node_modules/@emotion/react/dist/emotion-element-6a883da9.browser.esm.js"),jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js");const devicePixelRatio="undefined"!=typeof window?window.devicePixelRatio:1,StepFunctionGraph=({handleCloseContextMenu,handleContextClickNode,handleSelectedNode,highlightedKey,json,className})=>{const globalOffset=(0,react.useMemo)((()=>({scale:1,offset:{x:0,y:0},defaultOffset:{x:0,y:0}})),[]),pan=(0,react.useMemo)((()=>({start:{x:null,y:null},offset:{x:0,y:0}})),[]),canvasContainer=(0,react.useRef)(null),[zoom,setZoom]=(0,react.useState)(2),[observedElement,setObservedElement]=(0,react.useState)(null),[clickedNode,setClickedNode]=(0,react.useState)(null),[jsonHighlightedNode,setJsonHighlightedNode]=(0,react.useState)(null),clickHandler=(0,react.useRef)(null),contextMenuHandler=(0,react.useRef)(null),graphRef=(0,react.useRef)(null),initialDraw=(0,react.useRef)(!0),redraw=(0,react.useRef)(!1),setupDone=(0,react.useRef)(!1),initialWidth=(0,react.useRef)(0),handleRecenter=()=>{initialDraw.current=!0,pan.start={x:null,y:null},pan.offset={x:globalOffset.defaultOffset.x,y:globalOffset.defaultOffset.y},globalOffset.offset={x:globalOffset.defaultOffset.x,y:globalOffset.defaultOffset.y},zoom===devicePixelRatio?(setZoom(1.9999),setZoom(2.0001)):setZoom(2)},getClickHandler=(drawn,ctx,canvasRef,menuHandler=!1)=>function nodeClickHandler(e){e.preventDefault(),e.stopPropagation();const{x:offsetX,y:offsetY}=((canvas,evt)=>{const rect=canvas.getBoundingClientRect();return{x:(evt.clientX-rect.left)/(rect.right-rect.left)*canvas.width,y:(evt.clientY-rect.top)/(rect.bottom-rect.top)*canvas.height}})(canvasRef,e),rects=Array.from(drawn.values()).filter((node=>node.nodeType!==StepFunctionUtil_WorkFlowType.START&&node.nodeType!==StepFunctionUtil_WorkFlowType.END)),collision=((rects,x,y,ctx)=>{const invertedMatrix=ctx.getTransform().invertSelf(),transformedX=x*invertedMatrix.a+y*invertedMatrix.c+invertedMatrix.e,transformedY=x*invertedMatrix.b+y*invertedMatrix.d+invertedMatrix.f,collisions=[];for(let i=0,len=rects.length;i<len;i++){const rect=rects[i],{collisionBox}=rect;if(collisionBox){const left=collisionBox.left.x,right=collisionBox.right.x,top=collisionBox.top.y,bottom=collisionBox.bottom.y;right>=transformedX&&left<=transformedX&&bottom>=transformedY&&top<=transformedY&&collisions.push(rects[i])}}const highestDrawOrder=collisions.reduce(((accum,current)=>((!accum||current.vertex>accum.vertex)&&(accum=current),accum)),null);return collisions.length>0?highestDrawOrder:null})(rects,offsetX,offsetY,ctx);var node;menuHandler&&2===e.button?((node,e,ctx)=>{if(node){const nodeData=graph.getDataByVertex(node.vertex),[key]=Object.keys(nodeData);void 0!==handleContextClickNode&&handleContextClickNode(key,node.vertex,e,ctx)}})(collision,e,ctx):(setClickedNode(node=collision),null===node&&(setJsonHighlightedNode(null),handleCloseContextMenu&&handleCloseContextMenu()))},panToNode=node=>{const ctx=canvasContainer?.current?.getContext("2d");if(ctx&&node?.x){const xOffset=node.nodeType===StepFunctionUtil_WorkFlowType.PARALLEL?node.x+node.width/2:node.x;pan.offset.x=2*globalOffset.defaultOffset.x-xOffset,pan.offset.y=2*globalOffset.defaultOffset.y-node.y,globalOffset.offset.x=2*globalOffset.defaultOffset.x-xOffset,globalOffset.offset.y=2*globalOffset.defaultOffset.y-node.y}},graph=(0,react.useMemo)((()=>new StepFunctionGraph_Digraph),[json]),stepGraph=(0,react.useMemo)((()=>json.States&&generateStepFunctionGraph(json,graph)),[graph]),paths=(0,react.useMemo)((()=>stepGraph&&StepFunctionGraph_DigraphDFS.getAllDfsPaths(stepGraph.getAdjacencyMatrix(),[0])),[stepGraph]),calculateAndDraw=()=>{if(canvasContainer.current&&json&&json.States){const{height,width}=canvasContainer.current.getBoundingClientRect(),ctx=canvasContainer.current.getContext("2d");canvasContainer.current.style.width=`${width}`,canvasContainer.current.style.height=`${height}`;const scale=devicePixelRatio;if(canvasContainer.current.width=width*scale,canvasContainer.current.height=height*scale,ctx){ctx.scale(scale,scale);const draw=()=>{if(canvasContainer.current){const{height,width}=canvasContainer.current,highlightFindFn=datum=>{const[dataKey]=Object.keys(datum);return dataKey===highlightedKey},highlightedVertex=graph.getVertexByData(highlightFindFn),highlightedArray=highlightedVertex&&jsonHighlightedNode?[highlightedVertex]:[],drawn=new Map;if(clickHandler.current&&(canvasContainer.current.removeEventListener("click",clickHandler.current,!1),canvasContainer.current.removeEventListener("contextmenu",contextMenuHandler.current,!1)),clickHandler.current=getClickHandler(drawn,ctx,canvasContainer.current),contextMenuHandler.current=getClickHandler(drawn,ctx,canvasContainer.current,!0),canvasContainer.current.addEventListener("click",clickHandler.current,!1),canvasContainer.current.addEventListener("contextmenu",contextMenuHandler.current,!1),drawGraph(canvasContainer.current,drawn,paths,graph,ctx,pan,zoom,height,width,highlightedArray),highlightedVertex&&!redraw.current){const drawnVertex=drawn.get(highlightedVertex)??null;setJsonHighlightedNode(drawnVertex)}}},trackMouse=e=>{const offsetX=e.clientX-(pan.start.x||0),offsetY=e.clientY-(pan.start.y||0);pan.offset.x=globalOffset.offset.x+offsetX,pan.offset.y=globalOffset.offset.y+offsetY},startPan=e=>{canvasContainer.current&&(canvasContainer.current.addEventListener("mousemove",trackMouse),canvasContainer.current.addEventListener("mousemove",draw)),handleCloseContextMenu&&handleCloseContextMenu(),pan.start.x=e.clientX,pan.start.y=e.clientY},endPan=()=>{canvasContainer.current&&(canvasContainer.current.removeEventListener("mousemove",trackMouse),canvasContainer.current.removeEventListener("mousemove",draw)),pan.start.x=null,pan.start.y=null,globalOffset.offset.x=pan.offset.x,globalOffset.offset.y=pan.offset.y};setupDone.current?(canvasContainer.current.removeEventListener("mousedown",startPan),canvasContainer.current.removeEventListener("mouseleave",endPan),canvasContainer.current.removeEventListener("mouseup",endPan),canvasContainer.current.addEventListener("mousedown",startPan),canvasContainer.current.addEventListener("mouseleave",endPan),canvasContainer.current.addEventListener("mouseup",endPan)):(canvasContainer.current.addEventListener("mousedown",startPan),canvasContainer.current.addEventListener("mouseleave",endPan),canvasContainer.current.addEventListener("mouseup",endPan),setupDone.current=!0),initialDraw.current&&(()=>{const ctx=canvasContainer?.current?.getContext("2d");if(ctx){const center={x:-(zoom-1)*ctx.canvas.width/2,y:-(zoom-1)*(ctx.canvas.height/2)};globalOffset.offset.x=-center.x/2,globalOffset.offset.y=-center.y/2,globalOffset.defaultOffset.x=-center.x/2,globalOffset.defaultOffset.y=-center.y/2,pan.offset.x=-center.x/2,pan.offset.y=-center.y/2}})(),draw(),initialDraw.current=!1}}};return(0,react.useEffect)((()=>{const throttledResizeCallback=throttle(50,(entries=>{setObservedElement(entries)})),graphResizeObserver=(0,resizeObserver.Z)(throttledResizeCallback);return graphResizeObserver.observe(graphRef.current),()=>{graphResizeObserver.disconnect()}}),[]),(0,react.useEffect)((()=>{calculateAndDraw()}),[highlightedKey,clickedNode,json,observedElement,zoom]),(0,react.useEffect)((()=>{jsonHighlightedNode?(panToNode(jsonHighlightedNode),redraw.current=!0,calculateAndDraw()):calculateAndDraw()}),[jsonHighlightedNode]),(0,react.useEffect)((()=>{if(clickedNode){const node=graph.getDataByVertex(clickedNode.vertex);canvasContainer.current&&!initialDraw.current&&panToNode(node),handleSelectedNode(node,clickedNode.vertex)}else handleSelectedNode(null)}),[clickedNode]),(0,react.useEffect)((()=>{highlightedKey&&(redraw.current=!1,calculateAndDraw())}),[highlightedKey]),(0,react.useEffect)((()=>{const ctx=canvasContainer?.current?.getContext("2d");ctx&&graphRef.current&&initialWidth.current&&(pan.offset.x+=(ctx.canvas.width-(initialWidth.current||ctx.canvas.width))/4??0,globalOffset.defaultOffset.x+=(ctx.canvas.width-(initialWidth.current||ctx.canvas.width))/4??0,initialWidth.current=ctx.canvas.width)}),[observedElement]),(0,react.useEffect)((()=>{const ctx=canvasContainer?.current?.getContext("2d");ctx&&(initialWidth.current=ctx.canvas.width),handleRecenter()}),[]),(0,jsx_runtime.jsx)(emotion_element_6a883da9_browser_esm.a,{theme:theme.Z,children:(0,jsx_runtime.jsxs)(GraphContainer,{ref:graphRef,className,children:[(0,jsx_runtime.jsx)(StyledCanvas,{ref:canvasContainer}),(0,jsx_runtime.jsxs)(GraphControls,{children:[(0,jsx_runtime.jsx)("div",{onClick:handleRecenter,children:(0,jsx_runtime.jsx)(SvgNavigation,{})}),(0,jsx_runtime.jsx)("div",{onClick:()=>{Math.abs(zoom)<3&&setZoom(zoom+.2)},children:(0,jsx_runtime.jsx)(SvgPlus,{})}),(0,jsx_runtime.jsx)("div",{onClick:()=>{Math.abs(zoom)>1.2&&setZoom(zoom-.2)},children:(0,jsx_runtime.jsx)(SvgMinus,{})})]})]})})};StepFunctionGraph.displayName="StepFunctionGraph";const StepFunctionGraph_Graph=StepFunctionGraph;try{StepFunctionGraph.displayName="StepFunctionGraph",StepFunctionGraph.__docgenInfo={description:'Step Function Graph Component\n\nThe Step Function Graph takes AWS Step Function JSON and renders an interactive 2D canvas of how its states connect\ntogether. It can be panned by clicking in empty space and moving the mouse. It also takes a function "handleSelectedNode" that sends back which node has been clicked, so the\nthe consuming application can use the "highlightedKey" prop to let it know to highlight a node.\nThis component does not allow cycles, or nodes that connect such that a circular path is formed.',displayName:"StepFunctionGraph",props:{handleSelectedNode:{defaultValue:null,description:"Sends data stored with each node from the parsing step on click inside of any drawn node. Use this data to\nstore the node key for the highlightedKey prop if node highlighting is desired.",name:"handleSelectedNode",required:!0,type:{name:"(node: any, vertex?: number | undefined) => void"}},handleContextClickNode:{defaultValue:null,description:"Handle a right-click on any drawn node. This can be used to configure a context menu.",name:"handleContextClickNode",required:!1,type:{name:"((key: string, vertex: number, e: MouseEvent<HTMLCanvasElement, MouseEvent>, ctx: CanvasRenderingContext2D) => void)"}},handleCloseContextMenu:{defaultValue:null,description:"Action to run when a node context menu is closed.",name:"handleCloseContextMenu",required:!1,type:{name:"(() => void)"}},highlightedKey:{defaultValue:null,description:"This should be the node key from the AWS JSON and if supplied, will highlight that node in the graph.",name:"highlightedKey",required:!0,type:{name:"string | null"}},json:{defaultValue:null,description:"This is AWS Step Function JSON contained in an object. See the Storybook Canvas for detailed examples of what\nshould be provided.",name:"json",required:!0,type:{name:"any"}},className:{defaultValue:null,description:"The classes to pass to the step function graph container.",name:"className",required:!1,type:{name:"string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/StepFunctionGraph/Graph.tsx#StepFunctionGraph"]={docgenInfo:StepFunctionGraph.__docgenInfo,name:"StepFunctionGraph",path:"src/components/StepFunctionGraph/Graph.tsx#StepFunctionGraph"})}catch(__react_docgen_typescript_loader_error){}try{Graph.displayName="Graph",Graph.__docgenInfo={description:'Step Function Graph Component\n\nThe Step Function Graph takes AWS Step Function JSON and renders an interactive 2D canvas of how its states connect\ntogether. It can be panned by clicking in empty space and moving the mouse. It also takes a function "handleSelectedNode" that sends back which node has been clicked, so the\nthe consuming application can use the "highlightedKey" prop to let it know to highlight a node.\nThis component does not allow cycles, or nodes that connect such that a circular path is formed.',displayName:"Graph",props:{handleSelectedNode:{defaultValue:null,description:"Sends data stored with each node from the parsing step on click inside of any drawn node. Use this data to\nstore the node key for the highlightedKey prop if node highlighting is desired.",name:"handleSelectedNode",required:!0,type:{name:"(node: any, vertex?: number | undefined) => void"}},handleContextClickNode:{defaultValue:null,description:"Handle a right-click on any drawn node. This can be used to configure a context menu.",name:"handleContextClickNode",required:!1,type:{name:"((key: string, vertex: number, e: MouseEvent<HTMLCanvasElement, MouseEvent>, ctx: CanvasRenderingContext2D) => void)"}},handleCloseContextMenu:{defaultValue:null,description:"Action to run when a node context menu is closed.",name:"handleCloseContextMenu",required:!1,type:{name:"(() => void)"}},highlightedKey:{defaultValue:null,description:"This should be the node key from the AWS JSON and if supplied, will highlight that node in the graph.",name:"highlightedKey",required:!0,type:{name:"string | null"}},json:{defaultValue:null,description:"This is AWS Step Function JSON contained in an object. See the Storybook Canvas for detailed examples of what\nshould be provided.",name:"json",required:!0,type:{name:"any"}},className:{defaultValue:null,description:"The classes to pass to the step function graph container.",name:"className",required:!1,type:{name:"string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/StepFunctionGraph/Graph.tsx#Graph"]={docgenInfo:Graph.__docgenInfo,name:"Graph",path:"src/components/StepFunctionGraph/Graph.tsx#Graph"})}catch(__react_docgen_typescript_loader_error){}const StepFunctionGraph_stories={title:"Lakefront/StepFunctionGraph",component:StepFunctionGraph_Graph,argTypes:{handleSelectedNode:{action:"handleSelectedNode"}},parameters:{docs:{page:DocBlock.Z}}},Template=args=>{const[highlighted,setHighlighted]=(0,react.useState)(null);return(0,jsx_runtime.jsx)("div",{style:{height:700,width:"100%",maxWidth:1e3},children:(0,jsx_runtime.jsx)(StepFunctionGraph_Graph,{highlightedKey:highlighted,json:args.json,handleSelectedNode:node=>{if(node){const[key]=Object.keys(node);setHighlighted(key)}else setHighlighted(null);args.handleSelectedNode(node)}})})};Template.displayName="Template";const SimpleGraph=Template.bind({});SimpleGraph.args={json:{StartAt:"NodeA",States:{NodeA:{Type:"Task",Resource:"arn",Parameters:{FunctionName:"arn",Payload:{command:"",task_name:"NodeA",timeout_minutes:"720",processing_feature:"CPU",priority:"REAL_TIME",iam_role_arn:"","task_token.$":"","execution_arn.$":"","state_machine_arn.$":"","execution_start_date.$":"",data:""}},End:!0}}},highlightedKey:null};const ComplexGraph=Template.bind({});ComplexGraph.args={json:{Comment:"complex-json",StartAt:"NodeA",States:{NodeA:{Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"task","log_id.$":"","task_token.$":"","state_machine_arn.$":"","execution_arn.$":""}},Next:"Choice"},Choice:{Type:"Choice",Choices:[{Variable:"",StringGreaterThan:"",Next:"Parallel"},{Variable:"",StringEquals:"",Next:"SucceedNode"}],Default:"SucceedNode"},SucceedNode:{Type:"Succeed"},Parallel:{Type:"Parallel",End:!0,Branches:[{StartAt:"NodeB",States:{NodeB:{End:!0,Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"task","log_id.$":"","task_token.$":"","state_machine_arn.$":"","execution_arn.$":""}}}}},{StartAt:"NodeC",States:{NodeC:{Next:"Map",Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"task","log_id.$":"","task_token.$":"","state_machine_arn.$":"","execution_arn.$":""}}},Map:{Type:"Map",InputPath:"",ItemsPath:"",MaxConcurrency:0,Iterator:{StartAt:"MapNode",States:{MapNode:{Type:"Task",Resource:"arn",End:!0}}},ResultPath:"",End:!0}}},{StartAt:"NodeD",States:{NodeD:{Next:"WaitNode",Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"task","log_id.$":"","task_token.$":"","state_machine_arn.$":"","execution_arn.$":""}}},WaitNode:{Next:"RetryNode",Type:"Wait",Seconds:10},RetryNode:{Type:"Task",Next:"FailNode",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"task","log_id.$":"","task_token.$":"","state_machine_arn.$":"","execution_arn.$":""}},Retry:[{ErrorEquals:["States.Timeout","Lambda.Unknown"],IntervalSeconds:1,MaxAttempts:3,BackoffRate:1}]},FailNode:{Type:"Fail"}}}]}}},highlightedKey:null};const ChoiceGraph=Template.bind({});ChoiceGraph.args={json:{Comment:"choice-json",StartAt:"NodeA",States:{NodeA:{Type:"Task",Resource:"arn",InputPath:"",ResultPath:"",Parameters:{FunctionName:"arn",Payload:{command:"",task_name:"task",timeout_minutes:"120",processing_feature:"CPU",priority:"BATCH",iam_role_arn:"","task_token.$":"","execution_arn.$":"","state_machine_arn.$":"","execution_start_date.$":"",data:""}},Next:"NodeB"},NodeB:{Type:"Task",Resource:"arn",InputPath:"",ResultPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"task",timeout_minutes:"120",processing_feature:"CPU",priority:"BATCH",iam_role_arn:"","task_token.$":"","execution_arn.$":"","state_machine_arn.$":"","execution_start_date.$":"","data.$":""}},Next:"Choice"},Choice:{Type:"Choice",Choices:[{Not:{Variable:"",StringEquals:""},Next:"NodeC"},{Variable:"",StringEquals:"",Next:"NodeD"}],Default:"NodeD"},NodeD:{Type:"Succeed"},NodeC:{Type:"Task",Resource:"arn",InputPath:"",ResultPath:"",Parameters:{FunctionName:"arn",Payload:{command:"",task_name:"task",timeout_minutes:"120",processing_feature:"CPU",priority:"BATCH",iam_role_arn:"","task_token.$":"","execution_arn.$":"","state_machine_arn.$":"","execution_start_date.$":"","data.$":""}},Next:"Map"},Map:{Type:"Map",ItemsPath:"",ResultPath:"",Iterator:{StartAt:"NodeE",States:{NodeE:{Type:"Task",Resource:"arn",InputPath:"",ResultPath:"",Parameters:{FunctionName:"arn",Payload:{command:"",task_name:"task",timeout_minutes:"120",processing_feature:"CPU",priority:"BATCH",iam_role_arn:"","task_token.$":"","execution_arn.$":"","state_machine_arn.$":"","execution_start_date.$":"","data.$":""}},End:!0}}},End:!0}}},highlightedKey:null};const LongGraph=Template.bind({});LongGraph.args={json:{Comment:"long-json",StartAt:"Task",States:{Task:{Type:"Task",Resource:"arn",InputPath:"",ResultPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"Task"}},Next:"Choice"},Choice:{Type:"Choice",Choices:[{Next:"Parallel"},{Next:"NodeA"},{Next:"Node1"}],Default:"NodeA"},NodeA:{Next:"NodeB",Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"NodeA"}}},NodeB:{Next:"NodeC",Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"NodeB"}}},NodeC:{Next:"NodeD",Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"NodeC"}}},NodeD:{Next:"Succeed",Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"NodeD"}}},Succeed:{Type:"Succeed"},Parallel:{Type:"Parallel",Next:"AfterParallel",Branches:[{StartAt:"ParallelA",States:{ParallelA:{End:!0,Type:"Task",Resource:"arn",InputPath:"",ResultPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"ParallelA"}}}}},{StartAt:"ParallelB",States:{ParallelB:{End:!0,Type:"Task",Resource:"arn",InputPath:"",ResultPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"ParallelB"}}}}},{StartAt:"ParallelC",States:{ParallelC:{End:!0,Type:"Task",Resource:"arn",InputPath:"",ResultPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"ParallelC"}}}}}]},AfterParallel:{End:!0,Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{task_name:"AfterParallel"}}}}},highlightedKey:null};const MapGraph=Template.bind({});MapGraph.args={json:{StartAt:"NodeA",States:{NodeA:{Type:"Task",Resource:"arn",InputPath:"",Next:"MapA"},MapA:{Type:"Map",Iterator:{StartAt:"MapNode",States:{MapNode:{Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{command:"",command_params:{},task_name:"task",timeout_minutes:"720",processing_feature:"CPU",priority:"REAL_TIME",iam_role_arn:"","task_token.$":"","execution_arn.$":""}},Next:"MapB"},MapB:{Type:"Map",Iterator:{StartAt:"InnerMapNode",States:{InnerMapNode:{Type:"Task",Resource:"arn",Retry:[{}],InputPath:"",Parameters:{FunctionName:"arn",Payload:{command:"",command_params:{},task_name:"task",timeout_minutes:"720",processing_feature:"CPU",priority:"REAL_TIME",iam_role_arn:"","task_token.$":"","execution_arn.$":"","state_machine_arn.$":""}},End:!0}}},Next:"NodeB"},NodeB:{Type:"Task",Resource:"arn",InputPath:"",Parameters:{FunctionName:"arn",Payload:{command:"",command_params:{},task_name:"task",timeout_minutes:"720",processing_feature:"CPU",priority:"BATCH",iam_role_arn:"","task_token.$":"","execution_arn.$":"","state_machine_arn.$":""}},End:!0}}},End:!0}}},highlightedKey:null},SimpleGraph.parameters={...SimpleGraph.parameters,docs:{...SimpleGraph.parameters?.docs,source:{originalSource:"args => {\n  const [highlighted, setHighlighted] = useState<string | null>(null);\n  const handleSelectedNode = (node: any) => {\n    if (node) {\n      const [key] = Object.keys(node);\n      setHighlighted(key);\n    } else {\n      setHighlighted(null);\n    }\n    args.handleSelectedNode(node);\n  };\n  return <div style={{\n    height: 700,\n    width: '100%',\n    maxWidth: 1000\n  }}>\n            <StepFunctionGraph highlightedKey={highlighted} json={args.json} handleSelectedNode={handleSelectedNode} />\n        </div>;\n}",...SimpleGraph.parameters?.docs?.source}}},ComplexGraph.parameters={...ComplexGraph.parameters,docs:{...ComplexGraph.parameters?.docs,source:{originalSource:"args => {\n  const [highlighted, setHighlighted] = useState<string | null>(null);\n  const handleSelectedNode = (node: any) => {\n    if (node) {\n      const [key] = Object.keys(node);\n      setHighlighted(key);\n    } else {\n      setHighlighted(null);\n    }\n    args.handleSelectedNode(node);\n  };\n  return <div style={{\n    height: 700,\n    width: '100%',\n    maxWidth: 1000\n  }}>\n            <StepFunctionGraph highlightedKey={highlighted} json={args.json} handleSelectedNode={handleSelectedNode} />\n        </div>;\n}",...ComplexGraph.parameters?.docs?.source}}},ChoiceGraph.parameters={...ChoiceGraph.parameters,docs:{...ChoiceGraph.parameters?.docs,source:{originalSource:"args => {\n  const [highlighted, setHighlighted] = useState<string | null>(null);\n  const handleSelectedNode = (node: any) => {\n    if (node) {\n      const [key] = Object.keys(node);\n      setHighlighted(key);\n    } else {\n      setHighlighted(null);\n    }\n    args.handleSelectedNode(node);\n  };\n  return <div style={{\n    height: 700,\n    width: '100%',\n    maxWidth: 1000\n  }}>\n            <StepFunctionGraph highlightedKey={highlighted} json={args.json} handleSelectedNode={handleSelectedNode} />\n        </div>;\n}",...ChoiceGraph.parameters?.docs?.source}}},LongGraph.parameters={...LongGraph.parameters,docs:{...LongGraph.parameters?.docs,source:{originalSource:"args => {\n  const [highlighted, setHighlighted] = useState<string | null>(null);\n  const handleSelectedNode = (node: any) => {\n    if (node) {\n      const [key] = Object.keys(node);\n      setHighlighted(key);\n    } else {\n      setHighlighted(null);\n    }\n    args.handleSelectedNode(node);\n  };\n  return <div style={{\n    height: 700,\n    width: '100%',\n    maxWidth: 1000\n  }}>\n            <StepFunctionGraph highlightedKey={highlighted} json={args.json} handleSelectedNode={handleSelectedNode} />\n        </div>;\n}",...LongGraph.parameters?.docs?.source}}},MapGraph.parameters={...MapGraph.parameters,docs:{...MapGraph.parameters?.docs,source:{originalSource:"args => {\n  const [highlighted, setHighlighted] = useState<string | null>(null);\n  const handleSelectedNode = (node: any) => {\n    if (node) {\n      const [key] = Object.keys(node);\n      setHighlighted(key);\n    } else {\n      setHighlighted(null);\n    }\n    args.handleSelectedNode(node);\n  };\n  return <div style={{\n    height: 700,\n    width: '100%',\n    maxWidth: 1000\n  }}>\n            <StepFunctionGraph highlightedKey={highlighted} json={args.json} handleSelectedNode={handleSelectedNode} />\n        </div>;\n}",...MapGraph.parameters?.docs?.source}}};const __namedExportsOrder=["SimpleGraph","ComplexGraph","ChoiceGraph","LongGraph","MapGraph"]},"./src/lib/hooks/resizeObserver.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>__WEBPACK_DEFAULT_EXPORT__});const __WEBPACK_DEFAULT_EXPORT__=callback=>new ResizeObserver(callback)}}]);